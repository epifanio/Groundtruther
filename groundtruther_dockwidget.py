# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GroundTrutherDockWidget
                                 A QGIS plugin
 A toolset for Seafloor Caracterization
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-09
        git sha              : $Format:%H$
        copyright            : (C) 2023 by epinux
        email                : epiesasha@me.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, pyqtSlot
from qgis.utils import iface
from qgis.core import QgsPointXY, QgsRectangle, QgsGeometry, QgsWkbTypes, QgsProject
from qgis.gui import QgsVertexMarker, QgsMapToolEmitPoint, QgsRubberBand

from sys import platform

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

import requests
import pandas as pd
from pathlib import Path
import pyqtgraph as pg
from skimage.io import imread
import numpy as np
from scipy import spatial

from qgis.core import QgsMapLayerType

from groundtruther.configure import get_settings, ConfigDialog, error_message
from groundtruther.ioutils import parse_annotation, get_layer_info, send_layer_as_geojson, convert_to_geojson_using_gdal

from groundtruther.pygui.Ui_groundtruther_dockwidget_base import Ui_GroundTrutherDockWidgetBase  
from groundtruther.pygui.hbc_browser_gui import HBCBrowserGui
from groundtruther.pygui.image_metadata_gui import ImageMetadata, ExtendedDateTimeEdit
from groundtruther.pygui.app_settings_gui import AppSettings
from groundtruther.pygui.kmlsave_gui import SaveKml
from groundtruther.pygui.querybuilder_gui import QueryBuilder
from groundtruther.pygui.grass_settings_gui import GrassSettings

#from groundtruther.pygui.grass_mdi_gui import GrassMdi

from groundtruther.pygui.grass_mdi_gui import GrassTools

from groundtruther.grassconfig import GrassConfigDialog
from groundtruther.run_geomorphon_mdi import GeoMorphonWidget
from groundtruther.run_paramscale_mdi import ParamScaleWidget
from groundtruther.run_grm_lsi_mdi import GrmLsiWidget
import groundtruther.resources_rc

 
from PyQt5.QtCore import Qt

# Create a subclass of pg.ImageView
class MyImageView1(pg.ImageView):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            print("Left mouse button pressed at position:", event.pos())
        elif event.button() == Qt.RightButton:
            print("Right mouse button pressed at position:", event.pos())
            

class CustomGraphItem(pg.GraphItem):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.custom_attribute = None

    def setCustomAttribute(self, value):
        self.custom_attribute = value

    def getCustomAttribute(self):
        return self.custom_attribute

            
class MyImageView(pg.ImageView):
    mousePressEventSignal = pyqtSignal(object)
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.plot_items = []  # Store the GraphItems
        
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            pos = event.pos()
            
            for item in self.plot_items:
                if item.sceneBoundingRect().contains(pos):
                    print("Mouse position intersects GraphItem:", item)
                    print("Mouse position intersects GraphItem:", item.getCustomAttribute())
                    self.mousePressEventSignal.emit(item.getCustomAttribute())
                    item.setPen('w')
                else:
                    item.setPen('r')
                    #self.mousePressEventSignal.emit('None')
                    
            
class GroundTrutherDockWidget(QtWidgets.QDockWidget, Ui_GroundTrutherDockWidgetBase):

    closingPlugin = pyqtSignal()
    send_image_path = pyqtSignal(str)
    send_imagemetadata_string = pyqtSignal(str)

    def __init__(self, parent=None):
        """Constructor."""
        super(GroundTrutherDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.canvas = iface.mapCanvas()
        self.project = QgsProject.instance()
        self.w = HBCBrowserGui()
        self.setupUi(self)
        self.setWidget(self.w)
        #self.config = os.environ.get('HBC_CONFIG')
        self.config = os.path.join(os.path.dirname(__file__), 'config/config.yaml')
        self.dialog = ConfigDialog()
        self.settings = get_settings(self.config)
        if not self.settings:
            self.show_dialog()
            self.settings = get_settings(self.config)
        self.grass_dialog = GrassConfigDialog()
        self.imagelist = []
        self.imageindex = 1
        self.rangevalue = self.w.range.value()
        self.dirname = self.settings["HabCam"]["imagepath"]
        self.metadatafile = self.settings["HabCam"]["imagemetadata"]
        self.imageannotationfile = self.settings["HabCam"]["imageannotation"]
        self.grass_api_endpoint = self.settings["Processing"]["grass_api_endpoint"]
        self.annotation_confidence_treshold = (
            self.w.annotation_confidence_spinBox.value()
        )
        self.projection = "+proj=utm +no_defs +zone=19 +a=6378137 +rf=298.257223563 +towgs84=0.000,0.000,0.000 +to_meter=1"
        self.graph_items = []
        self.m1 = None
        self.image_point_built = False
        self.parsed_query = None
        self.init_ui()
        # hide for QGIS PlugIn
        self.w.gisTools.hide()
        self.w.gisTools_logger.hide()
        self.w.actionGisTools.setVisible(True)
        self.w.actionQuit.setVisible(False)
        # print(self.parent.plugin_dir) # = os.path.dirname(__file__))
        self.grassenabled = False
        self.r = None
        self.annotation_box_linewidth = 1
        self.annotation_box_vertexsize = 15
        print(self.actions)
        print(iface)



    def init_ui(self):
        """docstring"""
        self.region_response = None
        # self.imv = pg.ImageView(self.w)
        self.imv = MyImageView(self.w) 
        self.w.setCentralWidget(self.imv)
        self.imv.mousePressEventSignal.connect(self.setStausMessage)
        self.appsettings = AppSettings()
        self.grass_config_widget = GrassSettings()
        self.w.toolWidget.hide()
        # TODO: remove gistools
        self.w.gisTools.hide()
        self.w.fwd.clicked.connect(self.increaseimageindex)
        self.w.rwd.clicked.connect(self.decreaseimageindex)
        # Image Index
        self.w.ImageIndexSlider.valueChanged.connect(
            self.setValueImageIndexspinBox)
        self.w.ImageIndexspinBox.valueChanged.connect(
            self.setValueImageIndexSlider)
        self.w.ImageStepspinBox.valueChanged.connect(
            self.setImageIndexStepValue)
        self.w.ImageIndexSlider.valueChanged.connect(self.add_image)

        self.image = QLabel()

        self.w.latitude = QLineEdit()
        self.w.longitude = QLineEdit()
        self.w.longitude.setFocusPolicy(Qt.NoFocus)
        self.w.latitude.setFocusPolicy(Qt.NoFocus)
        self.w.latitude.setFixedWidth(90)
        self.w.longitude.setFixedWidth(90)
        self.w.longitude.setText("0")
        self.w.latitude.setText("0")
        self.w.statusbar.addPermanentWidget(self.w.latitude, stretch=0)
        self.w.statusbar.addPermanentWidget(self.w.longitude, stretch=0)
        

        # self.myProj = pyproj.Proj("+proj=utm +no_defs +zone=19 +a=6378137 +rf=298.257223563 +towgs84=0.000,0.000,0.000 +to_meter=1")
        self.myProj = self.projection
        self.w.range.valueChanged.connect(self.setValuerangeSpinBox)
        # self.getImageMetadata_hard()
        self.w.actionTools.triggered.connect(self.showTools)
        self.w.actionGisTools.triggered.connect(self.showGisTools)
        #self.w.actionImageBrowser.triggered.connect(self.showImageBrowser)
        self.w.actionImageBrowser.triggered.connect(self.showImageViewer)
        # self.w.actionWizard.triggered.connect(self.showPreferences)
        self.w.actionWizard.triggered.connect(self.show_dialog)
        # self.w.refresh.clicked.connect(self.on_send)
        if platform == "darwin":
            self.w.fwd.hide()
            self.w.rwd.hide()
        # self.w.refresh.hide()
        #
        #
        self.imagemetadata_gui = ImageMetadata()
        self.w.tools.insertTab(0, self.imagemetadata_gui, "Image Metadata")
        self.savekml = SaveKml()
        # emit image path to savekml widget
        self.send_image_path.connect(self.savekml.from_main_imagepath_signal)
        # self.send_image_path.connect(self.savekml.from_main_imagepath_signal)
        self.send_imagemetadata_string.connect(
            self.savekml.from_main_imagemetadata_signal)
        #
        #
        self.w.tools.insertTab(1, self.savekml, "Report Builder")
        self.querybuilder = QueryBuilder(self)
        self.w.tools.insertTab(2, self.querybuilder, "BS Query Builder")
        #

        # self.qgis_widget_gui = myMainClass(self)

        # self.w.gisToolSplitter.insertWidget(0, self.qgis_widget_gui)

        # self.w.actionQuit.triggered.connect(self.quitAll)
        self.set_settings()
        #
        self.querybuilder.send_2dgraph_path.connect(
            self.savekml.from_querybuilder_2dplot_signal
        )
        self.querybuilder.send_3dgraph_path.connect(
            self.savekml.from_querybuilder_3dplot_signal
        )
        #
        self.querybuilder.send_selected_points_path.connect(
            self.savekml.from_querybuilder_selected_points_signal
        )
        #
        # self.w.refresh.clicked.connect(self.close_pyqtgraph)
        self.w.annotation_confidence_spinBox.valueChanged.connect(
            self.setValue_annotation_confidence
        )
        self.w.actionAnnotation.triggered.connect(self.showAnnotationThreshold)
        self.w.annotation_confidence_spinBox.hide()
        self.w.annotation_confidence_spinBox_label.hide()

        self.init_grass_ui()
        self.init_grass_toolbar()
        # self.region_response = None
        self.w.show()


    def init_grass_toolbar(self):
        self.w.actiongrass_settings.triggered.connect(self.show_grass_dialog)

    def show_grass_dialog(self):
        """docstring"""
        self.grass_dialog.exec_()
        print(self.grass_dialog.grassenabled)   
        if self.grass_dialog.grassenabled:
            self.init_grass_contextual_menu()
    

    def init_grass_contextual_menu(self):
        if self.grass_dialog.grassenabled:
            self.w.gisTools_logger.setText("GRASS GIS enabled")
            self.action_import_raster = QAction( u"Import selected layer into GRASS Server")
            # self.action_import_raster.triggered.connect(lambda: print('raster action triggered - import'))
            self.action_import_raster.triggered.connect(self.import_active_raster_layer_to_grass)
            self.action_set_computational_region_from_raster = QAction( u"Set GRASS Server Computational Region to layer extent")
            # self.action_set_computational_region_from_raster.triggered.connect(lambda: print('raster action triggered - set region'))
            self.action_import_raster.triggered.connect(self.set_grass_region_from_raster)
            iface.addCustomActionForLayerType(self.action_import_raster, 'GroundTruther', QgsMapLayerType.RasterLayer, True)
            iface.addCustomActionForLayerType(self.action_set_computational_region_from_raster, 'GroundTruther', QgsMapLayerType.RasterLayer, True)
            self.action_import_vector = QAction( u"Import selected layer into GRASS Server")
            # self.action_import_vector.triggered.connect(lambda: print('vector action triggered - import'))
            self.action_import_vector.triggered.connect(self.import_active_vector_layer_to_grass)
            self.action_set_computational_region_from_vector = QAction( u"Set GRASS Server Computational Region to layer extent")
            # self.action_set_computational_region_from_vector.triggered.connect(lambda: print('vector action triggered - set region'))
            self.action_set_computational_region_from_vector.triggered.connect(self.set_grass_region_from_vector)
            iface.addCustomActionForLayerType(self.action_import_vector, 'GroundTruther', QgsMapLayerType.VectorLayer, True)
            iface.addCustomActionForLayerType(self.action_set_computational_region_from_vector, 'GroundTruther', QgsMapLayerType.VectorLayer, True)
            # Create the main action that triggers the submenu
            self.main_action = QAction("Custom Menu", iface.mainWindow())
            self.main_action.triggered.connect(lambda: self.show_custom_submenu(iface.activeLayer()))
            iface.addCustomActionForLayerType(self.main_action, 'My new Vector Menu', QgsMapLayerType.VectorLayer, True)
            
            
    def set_grass_region_from_raster(self):
        print('raster action triggered - set region')
        print(iface.activeLayer())
        print(get_layer_info(iface.activeLayer()))
        
    def set_grass_region_from_vector(self):
        print('vector action triggered - set region')
        print(iface.activeLayer())
        print(get_layer_info(iface.activeLayer()))
        
        selected_features = iface.activeLayer().selectedFeatures()
    
        # Loop through the selected features
        selected_geometries = []
        x_min = []
        y_min = []
        x_max = []
        y_max = []
        for feature in selected_features:
            # Get the feature ID
            feature_id = feature.id()
        
            # Get the geometry of the feature
            geom = feature.geometry()
        
            # Get attributes of the feature
            attrs = feature.attributes()
        
            # Print feature ID, geometry, and attributes
            print(f"Feature ID: {feature_id}")
            print(f"Geometry: {geom.asWkt()}")  # Print geometry as WKT
            print(f"Attributes: {attrs}")
            rect = geom.boundingBox()
            x_min.append(rect.xMinimum())
            y_min.append(rect.yMinimum())
            x_max.append(rect.xMaximum())
            y_max.append(rect.yMaximum())
            
            # selected_geometries.append([x_min, y_min, x_max, y_max])
            # print(dir(geom.boundingBox().toString()))
        xx_min = min(x_min)
        yy_min = min(y_min)
        xx_max = max(x_max)
        yy_max = max(y_max)
        bbox_selection = [xx_min, yy_min, xx_max, yy_max]
        print(bbox_selection)
        # add a vector layer to the map, showing the computed bounding box
        
        
    def import_active_raster_layer_to_grass(self):
        print('raster action triggered - import raster')
        print(iface.activeLayer()) 
        print(get_layer_info(iface.activeLayer()))
        
    def import_active_vector_layer_to_grass(self): 
        print('vector action triggered - import vector')
        print(iface.activeLayer())
        print(get_layer_info(iface.activeLayer()))
        print(convert_to_geojson_using_gdal(iface.activeLayer().source()), self.grass_api_endpoint)

    def init_grass_ui(self):
        # create the widget for grass which goes into the splitter
        self.grassWidgetContents = GrassTools(self) #QtWidgets.QWidget()
        self.grassWidgetContents.setObjectName("grassDockWidgetContents")
        self.w.gisToolSplitter.insertWidget(0, self.grassWidgetContents)

    def onZoomInClicked(self):
        self.grassWidgetContents.grass_mdi.gis_tool_report.zoomIn(1)

    def onZoomOutClicked(self):
        self.grassWidgetContents.grass_mdi.gis_tool_report.zoomOut(1)
    
    def onClearClicked(self):
        self.grassWidgetContents.grass_mdi.gis_tool_report.clear()

    def view_r_gemorphon(self, module):
        if self.r_gemorphon_window.isVisible():
            self.r_gemorphon_window.hide()
        else:
            self.r_gemorphon.get_rvr_list()
            self.r_gemorphon_window.show()

    def view_r_paramscale(self, module):
        if self.r_paramscale_window.isVisible():
            self.r_paramscale_window.hide()
        else:
            self.r_paramscale.get_rvr_list()
            self.r_paramscale_window.show()
             
    def view_r_grm_lsi(self, module):
        if self.r_grm_lsi_window.isVisible():
            self.r_grm_lsi_window.hide()
        else:
            self.r_grm_lsi.get_rvr_list()
            self.r_grm_lsi_window.show()
            
    
        
    def set_mdi_view(self, index):
        if self.mdi_view.itemText(index) == 'Cascade':
            self.grassWidgetContents.grass_mdi.grassTools.cascadeSubWindows()
        if self.mdi_view.itemText(index) == 'Tiled':
            self.grassWidgetContents.grass_mdi.grassTools.tileSubWindows()
        if self.mdi_view.itemText(index) == 'Minimize':
            for i in self.grassWidgetContents.grass_mdi.grassTools.subWindowList():
                print(i)
                if i.isVisible():
                    #i.hide()
                    i.showMinimized()
        if self.mdi_view.itemText(index) == 'Close':
            for i in self.grassWidgetContents.grass_mdi.grassTools.subWindowList():
                print(i)
                if i.isVisible():
                    i.hide()
                    #i.close()
            


    def set_settings(self):
        """docstring"""
        # self.dialog.exec_()
        self.settings = get_settings(self.config)
        self.dirname = self.settings["HabCam"]["imagepath"]
        self.metadatafile = self.settings["HabCam"]["imagemetadata"]
        self.imageannotationfile = self.settings["HabCam"]["imageannotation"]
        self.grass_api_endpoint = self.settings["Processing"]["grass_api_endpoint"]
        # self.annotation_confidence_treshold = 0.5  #

        #
        # self.imagelist = os.listdir(self.dirname)
        # self.imagelist.sort()
        # self.w.ImageIndexspinBox.setMaximum(len(self.imagelist) - 1)
        # self.w.ImageIndexSlider.setMaximum(len(self.imagelist) - 1)
        #
        try:
            self.imagemetadata_gui
        except AttributeError:
            self.imagemetadata_gui = ImageMetadata()
        if Path(self.metadatafile).is_file():
            try:
                self.imageMetadata = pd.read_parquet(self.metadatafile)
                # self.imageMetadata.index = pd.to_datetime(
                #    self.imageMetadata["index"])
                # self.imageMetadata = self.imageMetadata.loc[
                #    self.imageMetadata["Imagename"].isin(
                #        (i.replace(".jpg", "") for i in self.imagelist)
                #    )
                # ]

                self.w.ImageIndexspinBox.setMaximum(
                    len(self.imageMetadata) - 1)
                self.w.ImageIndexSlider.setMaximum(len(self.imageMetadata) - 1)

                if os.getenv("HBC_DEBUG") and os.getenv("HBC_DEBUG") == 'VERBOSE':
                    print("image metadata columns")
                    print(self.imageMetadata.columns)
                self.imagemetadata_gui.metadata_scroll_area.setEnabled(True)
                if Path(self.imageannotationfile).is_file():
                    # check the annotation file
                    # merge the info in the metadata and
                    # enable annotation tool
                    print("Annotation file loaded")
                    self.w.actionAnnotation.setEnabled(True)
                    annotations_by_image = parse_annotation(
                        self.imageannotationfile)
                    self.imageMetadata["Annotation"] = self.imageMetadata.Imagename.map(
                        annotations_by_image
                    )
                else:
                    self.w.actionAnnotation.setEnabled(False)
                self.kdt = spatial.KDTree(
                    self.imageMetadata[["habcam_lon", "habcam_lat"]].values)
            except OSError:
                print("OS error reading metadata")
            except pyarrow.lib.ArrowInvalid as message:
                error_message(
                    f"error reading {self.metadatafile}: \n" + str(message))
                self.imageMetadata = None
                # self.show_dialog()
        else:
            self.show_dialog()
            print(f"ther new path is {self.dialog.image_path.text()}")

    # def get_vquey_position(self, lat: float, lon: float):
    #     print("vquery at", lat, lon)
    #     index = self.getImageIndex(lon, lat)
    #     self.w.ImageIndexSlider.setValue(index)
    #     self.w.gisTools_logger.setText(
    #         f'Zoom to nearest Image: index # {index}')
    
    def set_grass_cpr(self, minlat, maxlat, minlon, maxlon):
        print('set_grass_cpr: ', minlat, maxlat, minlon, maxlon)
        # print(self.set_grass_region(float(minlat), float(maxlat), float(minlon), float(maxlon)).json())
        self.region_response = self.set_grass_region(float(minlat), float(maxlat), float(minlon), float(maxlon)).json()['data']['region']
        print(self.region_response)
        if self.r:
            self.canvas.scene().removeItem(self.r)
        self.r = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)  # polygon
        #self.r = QgsRubberBand(self.canvas)  # polyline
        points = [[QgsPointXY(maxlon, maxlat), QgsPointXY(minlon, maxlat), QgsPointXY(minlon, minlat), QgsPointXY(maxlon, minlat)]]
        self.r.setToGeometry(QgsGeometry.fromPolygonXY(points), None)
        #self.r.setToGeometry(QgsGeometry.fromPolyline(points), None)
        self.r.setWidth(3)
        self.r.setColor(QColor(255, 0, 0))
        self.r.setFillColor(QColor(0, 0, 0, 0))
        
    # placeholder to select a grass region from a combobox in the main toolbar
    # def select_grass_cpr(self, index):
    #     print(index)
    
    def get_query_message(self, stringa):
        print('stringa', stringa)
        # self.grass_mdi.gis_tool_report.setHtml(stringa)
        self.grassWidgetContents.grass_mdi.gis_tool_report.setHtml(stringa)
        
    def get_query_position(self, lat, lon):
        print('position', lat, lon)
        self.set_image_index(lat, lon)
        
    def set_image_index(self, lat: float, lon: float):
        print("vquery at", lat, lon)
        index = self.getImageIndex(lon, lat)
        self.w.ImageIndexSlider.setValue(index)
        # self.w.gisTools_logger.setText(
        #     f'Zoom to nearest Image: index # {index}')

    def get_grass_query_data_(self, lat:float, lon: float):
        grass_settings = self.grass_dialog.set_grass_location()
        if grass_settings['status'] == 'SUCCESS':
            grass_gisenv = grass_settings['data']['gisenv']
        if int(grass_settings['data']['region']['projection'].split(' ')[0]) == 1:
            # corner = [[minlon, maxlat], [maxlon, minlat]]
            headers = {
                'accept': 'application/json',
                'Content-Type': 'application/json',
            }

            json_data = {
                'location': {
                    'location_name': grass_gisenv['LOCATION_NAME'],
                    'mapset_name': grass_gisenv['MAPSET'],
                    'gisdb': grass_gisenv['GISDBASE'],
                },
                'coors': [[lon, lat]],
            }

            response = requests.post(
                f'{self.grass_api_endpoint}/api/m_proj', headers=headers, json=json_data, timeout=60)
            point = response.json()['data']
        else:
            point = [[lon, lat]]
        print(point)
        self.grassWidgetContents.grass_mdi.gis_tool_report.setHtml(str(point))




    def get_grass_query_data(self, lat:float, lon: float):
        print(lat, lon)
        headers = {
            'accept': 'application/json',
            'Content-Type': 'application/json',
        }
        grass_settings = self.grass_dialog.set_grass_location()
        # grass_layers = ['bathy']
        
        if grass_settings['status'] == 'SUCCESS':
            grass_gisenv = grass_settings['data']['gisenv']
        
        # params = {
        #     'location_name': grass_gisenv['LOCATION_NAME'],
        #     'mapset_name': grass_gisenv['MAPSET'],
        #     'gisdb': grass_gisenv['GISDBASE'],
        #     }
        # # response = requests.get('https://grassapi.wps.met.no/api/get_rvg_list', params=params, headers=headers)
        # response = requests.get(
        #     f'{self.grass_api_endpoint}/api/get_rvg_list',params=params, headers=headers, timeout=60)
        # grass_layers = response.json()['data']['raster']
        self.grassWidgetContents.get_checked_items()
        grass_layers = self.grassWidgetContents.checked_layers
        
        if int(grass_settings['data']['region']['projection'].split(' ')[0]) == 1:
            params = {'lonlat': 'true'}
        else:
            params = {'lonlat': 'false'}
        # corner = [[minlon, maxlat], [maxlon, minlat]]

        json_data = {
            'location': {
                'location_name': grass_gisenv['LOCATION_NAME'],
                'mapset_name': grass_gisenv['MAPSET'],
                'gisdb': grass_gisenv['GISDBASE'],
            },
            'coors': [lon, lat],
            'grass_layers': grass_layers,
        }

        response = requests.post(
            f'{self.grass_api_endpoint}/api/r_what',params=params, headers=headers, json=json_data, timeout=60)
        # point = response.json()['data']
        print('r_what_response: ', response.json())
        if response.json()['status'] == 'SUCCESS':
            results = "<br>".join([f"{list(i.keys())[0]}: {i[list(i.keys())[0]]['value']}  <br>" for i in response.json()['data'] if i[list(i.keys())[0]]['value'] != 'No data'])
            # values = [f"{i}: {response.json()[0][i]['value']}" for i in grass_layers]
            # value = response.json()[0]['bathy']['value']
            # print(point)
            # result = str(lon)+" "+str(lat)+"<br>"+str(values)
            self.grassWidgetContents.add_query_result(response.json()['data'])
        else:
            results = str(response.json())
        self.grassWidgetContents.grass_mdi.gis_tool_report.setHtml(results)

    def set_grass_region(self, minlat: float, maxlat: float, minlon: float, maxlon: float):
        grass_settings = self.grass_dialog.set_grass_location()
        if grass_settings['status'] == 'SUCCESS':
            grass_gisenv = grass_settings['data']['gisenv']
        print(grass_settings['data']['region']['projection'])
        if int(grass_settings['data']['region']['projection'].split(' ')[0]) == 1:
            # corner = [[minlon, maxlat], [maxlon, minlat]]
            headers = {
                'accept': 'application/json',
                'Content-Type': 'application/json',
            }

            json_data = {
                'location': {
                    'location_name': grass_gisenv['LOCATION_NAME'],
                    'mapset_name': grass_gisenv['MAPSET'],
                    'gisdb': grass_gisenv['GISDBASE'],
                },
                'coors': [[minlon, maxlat], [maxlon, minlat]],
            }

            response = requests.post(
                f'{self.grass_api_endpoint}/api/m_proj', headers=headers, json=json_data, timeout=60)
            corners = response.json()['data']
        else:
            corners = [[minlon, maxlat], [maxlon, minlat]]
        print('corners: ', corners)
        headers = {
                'accept': 'application/json',
                'Content-Type': 'application/json',
            }
        json_data = {
            'location': {
                'location_name': grass_gisenv['LOCATION_NAME'],
                'mapset_name': grass_gisenv['MAPSET'],
                'gisdb': grass_gisenv['GISDBASE'],
            },
            'bounds': {
                'n': corners[0][1],
                's': corners[1][1],
                'e': corners[1][0],
                'w': corners[0][0],
            },
            'resolution': {
                'resolution': 0,
            },
        }
        response = requests.post(
            f'{self.grass_api_endpoint}/api/set_region_bounds', headers=headers, json=json_data, timeout=60)
        return response
        # headers = {
        #     'accept': 'application/json',
        # }

        # params = {
        #     'location_name': grass_gisenv['LOCATION_NAME'],
        #     'mapset_name': grass_gisenv['MAPSET'],
        #     'gisdb': grass_gisenv['GISDBASE'],
        # }

        # response = requests.get(
        #     'http://localhost/api/get_current_region', params=params, headers=headers, timeout=60)
        # data = response.content
        
        # self.grass_region_bounds =  os.path.join(os.path.dirname(__file__), 'data' 'grass_region.geojson')
        
        # with open(self.grass_region_bounds, 'wb') as s:
        #     s.write(data)
        
        
        # self.w.gisToolSplitter.widget(1).remove_vector(
        #     self.grass_region_bounds, 'grass_region')
        # self.w.gisToolSplitter.widget(1).add_vector(
        #     self.grass_region_bounds, 'grass_region')
        # self.w.gisToolSplitter.widget(0).refresh()

        # self.w.gisToolSplitter.widget(2).show()
        # self.w.gisToolSplitter.widget(
        #     2).children()[0].itemAt(0).widget().setPlainText(f"{min_lon}, {min_lat}, {max_lon}, {max_lat}")


    def getImageIndex(self, lon, lat):
        distance, index = self.kdt.query([lon, lat])
        return index

    def clear_image_annotation(self):
        for i in self.graph_items:
            i.setData(
                pos=[],
                adj=[],
                pen=[],
                size=1,
                pxMode=False,
            )
            del i
        self.graph_items = []

    def setStausMessage(self, message):
        self.w.statusbar.showMessage(message)
        
    def decreaseimageindex(self):
        """docstring"""
        self.imageindex = self.imageindex - self.w.ImageStepspinBox.value()
        self.w.ImageIndexSlider.setValue(self.imageindex)
        self.w.ImageIndexspinBox.setValue(self.imageindex)
        self.w.ImageIndexspinBox.update()

    def increaseimageindex(self):
        """docstring"""
        self.imageindex = self.imageindex + self.w.ImageStepspinBox.value()
        self.w.ImageIndexSlider.setValue(self.imageindex)
        self.w.ImageIndexspinBox.setValue(self.imageindex)
        self.w.ImageIndexspinBox.update()

    def setValueImageIndexspinBox(self, z):
        """docstring"""
        self.imageindex = int(z)
        self.w.ImageIndexspinBox.setSingleStep(self.w.ImageStepspinBox.value())
        self.w.ImageIndexspinBox.setValue(self.imageindex)

    def setValueImageIndexSlider(self, z):
        """docstring"""
        self.imageindex = int(z)
        self.w.ImageIndexSlider.setSingleStep(self.w.ImageStepspinBox.value())
        self.w.ImageIndexSlider.setValue(self.imageindex)

    def setValuerangeSpinBox(self, r):
        """docstring"""
        self.rangevalue = int(r)
        self.w.range.setSingleStep(1)
        self.w.range.setValue(self.rangevalue)
        if self.w.zoomto.isChecked():
            self.zoom_to()

    def setImageIndexStepValue(self):
        """docstring"""
        self.w.ImageIndexspinBox.setSingleStep(self.w.ImageStepspinBox.value())
        self.w.ImageIndexSlider.setSingleStep(self.w.ImageStepspinBox.value())

    def close_pyqtgraph(self):
        self.querybuilder.close()
        
    def zoom_to(self):
        """docstring"""
        lon = float(self.w.longitude.text())
        lat = float(self.w.latitude.text())
        distance = float(self.rangevalue)
        # print(lon, lat, distance)
        

        self.w.statusbar.showMessage("System Status | Normal")

        distance = distance/10000
        rect = QgsRectangle(
            (float(lon)) - float(distance), 
            (float(lat)) - float(distance), 
            (float(lon)) + float(distance), 
            (float(lat)) + float(distance)
            )
        # # Get the map canvas
        # # del self.m1
        # # try:
        self.canvas.scene().removeItem(self.m1)
        self.m1 = QgsVertexMarker(self.canvas)
        self.m1.setCenter(QgsPointXY(float(lon), float(lat)))
        self.m1.setColor(QColor(255, 0, 0))  # (R,G,B)
        self.m1.setIconSize(10)
        self.m1.setIconType(QgsVertexMarker.ICON_X)
        self.m1.setPenWidth(3)
        self.canvas.setExtent(rect)
        self.canvas.refresh()
        
        # REMOVE VERTEX MARKER
        # self.w.gisToolSplitter.widget(1).canvas.scene().removeItem(self.m1)
        # self.m1 = qgis_gui.QgsVertexMarker(
        #     self.w.gisToolSplitter.widget(1).canvas)
        # self.m1.setCenter(qgis_core.QgsPointXY(float(lon), float(lat)))
        # self.m1.setColor(QtGui.QColor(255, 0, 0))  # (R,G,B)
        # self.m1.setIconSize(10)
        # self.m1.setIconType(qgis_gui.QgsVertexMarker.ICON_X)
        # self.m1.setPenWidth(3)
        # self.w.gisToolSplitter.widget(1).canvas.setExtent(rect)
        # self.w.gisToolSplitter.widget(1).canvas.refresh()

    def build_box(self, bbox):
        # self.annotation_box_linewidth = 1
        # self.annotation_box_vertexsize = 15
        pos = np.array(
            [
                [bbox[0], bbox[1]],
                [bbox[2], bbox[3]],
                [bbox[4], bbox[5]],
                [bbox[6], bbox[7]],
            ]
        )
        adj = np.array(
            [
                [0, 1],
                [1, 2],
                [2, 3],
                [3, 0],
            ]
        )
        symbols = ["o", "o", "o", "o"]
        lines = np.array(
            [
                (255, 0, 0, 255, self.annotation_box_linewidth),
                (255, 0, 0, 255, self.annotation_box_linewidth),
                (255, 0, 0, 255, self.annotation_box_linewidth),
                (255, 0, 0, 255, self.annotation_box_linewidth),
            ],
            dtype=[
                ("red", np.ubyte),
                ("green", np.ubyte),
                ("blue", np.ubyte),
                ("alpha", np.ubyte),
                ("width", float),
            ],
        )
        return pos, adj, lines, symbols

    def add_image_annotation(self):
        # annotation = self.imageMetadata[
        #     self.imageMetadata["Imagename"] == self.imagelist[self.imageindex][:-4]
        # ]["Annotation"]

        annotation = self.imageMetadata["Annotation"].iloc[self.imageindex]

        # print(annotation, type(annotation.values))
        # add treshold check for annotation confidence
        # if not annotation.isnull().values.any():
        if annotation is not np.nan:
            # print(annotation.values[0]["bbox"])
            # print(annotation.values[0]["Species"])
            # print(annotation.values[0]["Confidence"])
            # print(len(annotation.values[0]["bbox"]), len(annotation.values))
            self.clear_image_annotation()
            # for i, v in enumerate(annotation.values[0]["bbox"]):
            for i, bbox in enumerate(annotation["bbox"]):

                print("annotation_confidence_treshold: ",
                      self.annotation_confidence_treshold)
                if (
                    annotation["Confidence"][i]
                    >= self.annotation_confidence_treshold
                ):
                    print("annotation bbox", bbox)
                    print("annotation label", annotation["Species"][i])
                    print("annotation confidence treshold",
                          annotation["Confidence"][i])
                    self.g = CustomGraphItem()
                    self.g.setCustomAttribute(annotation["Species"][i])
                    # self.g = pg.GraphItem()
                    pos, adj, lines, symbols = self.build_box(
                        bbox["bbox"]
                    )
                    self.g.setData(
                        pos=pos,
                        adj=adj,
                        pen=lines,
                        size=15,
                        symbol=symbols,
                        pxMode=False,
                    )
                    self.imv.addItem(self.g)
                    self.imv.plot_items.append(self.g)
                    # print(self.imv.getImageItem())
                    self.g.setZValue(10)  # make sure ROI is drawn above image
                    self.graph_items.append(self.g)
        else:
            print("no annotation found")
            self.clear_image_annotation()

    def count_string_occurrences(self, string_list):
        count_dict = {}
        for string in string_list:
            count_dict[string] = count_dict.get(string, 0) + 1
        return count_dict

    def add_image(self):
        
        """docstring"""
        self.imv.clear()
        if any(self.imagelist) is not None:
            path = Path(os.path.join(
                self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg"))
            self.pixmap = QPixmap(
                os.path.join(
                    self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg")
            )
            self.imv.imageItem.axisOrder = "row-major"
            # check if the imageviewer is hidden or not
            if self.w.actionImageBrowser.isChecked():
                self.imv.show()

            self.imv.setImage(
                imread(os.path.join(
                    self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg"))
            )

            if self.w.actionAnnotation.isChecked():
                self.add_image_annotation()
            else:
                self.clear_image_annotation()
            #
            # self.imageeast = str(self.imageMetadata['Xutm'].values[0])
            # self.imagenorth = str(self.imageMetadata['Yutm'].values[0])
            # self.w.statusbar.showMessage("Image %s" % self.imageMetadata.index[0])
            
            if self.imageMetadata is not None:
                
                # try:
                # record = self.imageMetadata[
                #     self.imageMetadata["Imagename"]
                #     == self.imagelist[self.imageindex][:-4]
                # ]
                # TODO: check if the record is empty
                # TODO: ideally we need to dynamically generate the widgets to host metadata
                # maybe no worth to display all of them - add some fields ina white/black list
                record = self.imageMetadata.iloc[self.imageindex]
                print(" #################### " )
                print("record:", record)
                print(" #################### " )
                
                self.imagemetadata_gui.metadata_scroll_area.setEnabled(True)
            
                if len(record) != 0:
                    main_layout = QVBoxLayout()
                    time_layout = QHBoxLayout()
                    time_label = QLabel("Time")
                    data_time = ExtendedDateTimeEdit()
                    data_time.setDateTime(record.name)
                    data_time.setMaximumSize(QSize(250, 16777215))
                    data_time.setMinimumWidth(160)
                    data_time.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Preferred)
                    data_time.setReadOnly(True)
                    data_time.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
                    time_layout.addWidget(time_label)
                    spacer = QSpacerItem(20, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
                    time_layout.addItem(spacer)
                    time_layout.addWidget(data_time)
                    main_layout.addLayout(time_layout)
                    for i in self.imageMetadata.columns:
                        print(i, record[i], type(record[i]))
                        item_layout = QHBoxLayout()
                        label = QLabel(i)
                        if i == "Imagename":
                            line_edit = QLabel()
                            line_edit.setText(
                                '<a href="file://%s">%s</a>'
                                % (
                                    os.path.join(
                                        self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg"),
                                    str(record["Imagename"]),
                                )
                            )
                            line_edit.setOpenExternalLinks(True)
                        else:
                            if i == "Annotation" and isinstance(record[i], dict):
                                occurrences = self.count_string_occurrences(record[i]["Species"])
                                line_edit = QTextEdit()
                                line_edit.setReadOnly(True)
                                line_edit.setPlainText("\n".join([f"{string}: {count}" for string, count in occurrences.items()]))
                            else:
                                line_edit = QLineEdit(str(record[i]))
                                line_edit.setReadOnly(True)
                        line_edit.setMaximumSize(QSize(250, 16777215))
                        
                        line_edit.setMinimumWidth(160)
                        line_edit.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Preferred)
                        item_layout.addWidget(label)
                        spacer = QSpacerItem(20, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
                        item_layout.addItem(spacer)
                        item_layout.addWidget(line_edit)
                        main_layout.addLayout(item_layout)
                        
                        
                        
                    print(record.name, type(record.name))
                
                    self.imagemetadata_gui.metadata_scroll_area.setWidgetResizable(True)
                    scroll_widget = QWidget()
                    scroll_widget.setLayout(main_layout)
                    self.imagemetadata_gui.metadata_scroll_area.setWidget(scroll_widget)
                    
                    self.w.longitude.setText(
                        str(round(record["habcam_lon"], 8))
                    )
                    self.w.latitude.setText(
                        str(round(record["habcam_lat"], 8))
                    )

                    # # Hardcoded for Habcam METADATA
                    # self.imagemetadata_gui.imageeast.setText(
                    #     str(round(record["Xutm_adj"], 2))
                    # )
                    # self.imagemetadata_gui.imagenorth.setText(
                    #     str(round(record["Yutm_adj"], 2))
                    # )
                    # self.imagemetadata_gui.hbcdepth.setText(
                    #     str(record["V_Depth"])
                    # )
                    # self.imagemetadata_gui.waterdepth.setText(
                    #     str(record["Water_Depth"])
                    # )
                    # self.imagemetadata_gui.altimeter.setText(
                    #     str(record["Altimeter"])
                    # )
                    # self.imagemetadata_gui.salinity.setText(
                    #     str(record["Salinity"])
                    # )
                    # self.imagemetadata_gui.temperature.setText(
                    #     str(record["Temp"])
                    # )
                    # self.imagemetadata_gui.O2.setText(
                    #     str(record["O2"]))
                    # self.imagemetadata_gui.CDOM.setText(
                    #     str(record["Cdom"])
                    # )
                    # self.imagemetadata_gui.chlorophyll.setText(
                    #     str(record["Chlorophyll"])
                    # )
                    # self.imagemetadata_gui.turbidity.setText(
                    #     str(record["Turb"])
                    # )
                    # # test QtDateTime

                    # self.imagemetadata_gui.dateTimeEdit.setDateTime(
                    #     record.name)
                    # self.imagemetadata_gui.linklabel.setText(
                    #     '<a href="file://%s">%s</a>'
                    #     % (
                    #         os.path.join(
                    #             self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg"),
                    #         str(record["Imagename"]),
                    #     )
                    # )
                    # self.imagemetadata_gui.linklabel.setOpenExternalLinks(
                    #     True)

                    self.w.statusbar.showMessage(
                        "Image : %s" % self.imageindex)

                    if self.w.zoomto.isChecked():
                        self.zoom_to()
                    self.on_send()
                else:
                    print(
                        "record lenght:",
                        len(record),
                        "for image index: ",
                        self.imageindex,
                        self.imageMetadata["Imagename"].iloc[self.imageindex],
                    )
                    #
                # except:
                #     error_message(
                #         f"image metadata not set properly- check settings \n \n image metadata widget will be disabled"
                #     )
                #     self.imageMetadata = None
                #     self.imagemetadata_gui.metadata_scroll_area.setEnabled(
                #         False)
            else:
                print("image metadata disabled - reconfigure the settings")
                self.imagemetadata_gui.metadata_scroll_area.setEnabled(False)

        else:
            print("both image path not be set")
            print(" --- ")

    @pyqtSlot()
    def on_send(self):
        """docstring"""
        image_path = os.path.join(
            self.dirname, self.imageMetadata["Imagename"].iloc[self.imageindex]+".jpg")
        self.send_image_path.emit(image_path)
        md_str = pd.DataFrame(
            [self.imageMetadata[['Longitude',
                                 'Latitude',
                                 'V_Depth',
                                 'Water_Depth',
                                 'Altimeter',
                                 'Salinity',
                                 'Temp',
                                 'O2',
                                 'Cdom',
                                 'Chlorophyll',
                                 'Turb']].iloc[self.imageindex]]).to_html()
        self.send_imagemetadata_string.emit(md_str)
        if not self.savekml.lock_location.isChecked():
            self.savekml.longitude.setText(self.w.longitude.text())
            self.savekml.latitude.setText(self.w.latitude.text())
        # update query builder widgets
        if not self.querybuilder.lock_location.isChecked():
            self.querybuilder.qb_longitude.setText(self.w.longitude.text())
            self.querybuilder.qb_latitude.setText(self.w.latitude.text())
            
    def show_dialog(self):
        """docstring"""
        self.dialog.exec_()
        self.settings = get_settings(self.config)
        self.dirname = self.settings["HabCam"]["imagepath"]
        self.metadatafile = self.settings["HabCam"]["imagemetadata"]
        self.imageannotationfile = self.settings["HabCam"]["imageannotation"]
        self.grass_api_endpoint = self.settings["Processing"]["grass_api_endpoint"]
        #
        # self.imagelist = os.listdir(self.dirname)
        # self.imagelist.sort()
        # self.w.ImageIndexspinBox.setMaximum(len(self.imagelist) - 1)
        # self.w.ImageIndexSlider.setMaximum(len(self.imagelist) - 1)
        #
        try:
            self.imagemetadata_gui
        except AttributeError:
            self.imagemetadata_gui = ImageMetadata()
        if Path(self.metadatafile).is_file():
            try:
                self.imageMetadata = pd.read_parquet(self.metadatafile)
                self.w.ImageIndexspinBox.setMaximum(
                    len(self.imageMetadata) - 1)
                self.w.ImageIndexSlider.setMaximum(len(self.imageMetadata) - 1)
                # self.imageMetadata.index = pd.to_datetime(
                #     self.imageMetadata["index"])
                # self.imageMetadata = self.imageMetadata.loc[
                #     self.imageMetadata["Imagename"].isin(
                #         (i.replace(".jpg", "") for i in self.imagelist)
                #     )
                # ]
                if os.getenv("HBC_DEBUG") and os.getenv("HBC_DEBUG") == 'VERBOSE':
                    print("image metadata columns")
                    print(self.imageMetadata.columns)
                self.imagemetadata_gui.metadata_scroll_area.setEnabled(True)
                if Path(self.imageannotationfile).is_file():
                    # check the annotation file
                    # merge the info in the metadata and
                    # enable annotation tool
                    print("Annotation file loaded")
                    self.w.actionAnnotation.setEnabled(True)
                    annotations_by_image = parse_annotation(
                        self.imageannotationfile)
                    self.imageMetadata["Annotation"] = self.imageMetadata.Imagename.map(
                        annotations_by_image
                    )
                else:
                    self.w.actionAnnotation.setEnabled(False)
                self.kdt = spatial.KDTree(
                    self.imageMetadata[["habcam_lon", "habcam_lat"]].values)
            except OSError:
                print("OS error reading metadata")
            except pyarrow.lib.ArrowInvalid as message:
                error_message(
                    f"error reading {self.metadatafile}: \n" + str(message))
                self.imageMetadata = None
                # self.show_dialog()
        else:
            self.show_dialog()
            print(f"ther new path is {self.dialog.image_path.text()}")

    def showTools(self):
        """docstring"""
        if self.w.toolWidget.isVisible():
            self.w.toolWidget.hide()
        else:
            self.w.toolWidget.show()

    def showGisTools(self):
        """docstring"""
        if self.w.gisTools.isVisible():
            self.w.gisTools.hide()
            self.w.gisTools_logger.hide()
        else:
            self.w.gisTools.show()
            #self.w.gisTools_logger.show()

    def showImageViewer(self):
        """docstring"""
        if self.imv.isVisible():
            self.imv.hide()
            self.imageviewer_is_hidden = True
            if self.w.link_to_image_viewer.isChecked():
                self.w.imageBrowsing.hide()
        else:
            self.imv.show()
            self.imageviewer_is_hidden = False
            if self.w.link_to_image_viewer.isChecked():
                self.w.imageBrowsing.show()

    def showImageBrowser(self):
        """docstring"""
        if self.imv.isVisible():
            #self.imv.hide()
            self.w.imageBrowsing.hide()
            self.imageviewer_is_hidden = True
        else:
            #self.imv.show()
            self.w.imageBrowsing.show()
            self.imageviewer_is_hidden = False


    def setValue_annotation_confidence(self):
        self.annotation_confidence_treshold = (
            self.w.annotation_confidence_spinBox.value()
        )

    def showAnnotationThreshold(self):
        """docstring"""
        if self.w.annotation_confidence_spinBox.isVisible():
            self.w.annotation_confidence_spinBox.hide()
            self.w.annotation_confidence_spinBox_label.hide()
        else:
            self.w.annotation_confidence_spinBox.show()
            self.w.annotation_confidence_spinBox_label.show()
            
    # def quitAll(self):
    #     """docstring"""
    #     self.querybuilder.close()
    #     qApp.quit()
        
        
    def closeEvent(self, event):
        if self.r is not None:
            self.canvas.scene().removeItem(self.r)
        if self.m1 is not None:
            self.canvas.scene().removeItem(self.m1)
        self.closingPlugin.emit()
        event.accept()
